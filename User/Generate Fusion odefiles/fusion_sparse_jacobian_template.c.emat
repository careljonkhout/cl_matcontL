#include <math.h>
#include "mex.h"

#define n_inputs    5
#define n_outputs   1
#define N           <%= num2str(N)     %>
#define nzmax       <%= num2str(nzmax) %>

#define input_t     0
#define input_xxxxx 1
#define input_a     2
#define input_b     3
#define input_q_inf 4


void fusion_jacobian(double* xxxxx, double a, double b, double q_inf, double* jacobian);

void mexFunction(int nlhs, mxArray *plhs[],
                 int nrhs, const mxArray *prhs[]) {
    double a,b,q_inf;               /* input scalars */
    double *xxxxx;                  /* input vector  */

    /* check for proper number of arguments */
    if(nrhs != n_inputs) {
        mexErrMsgIdAndTxt("fusion_dydt_125:nrhs","Five inputs required.");
    }
    if(nlhs != n_outputs) {
        mexErrMsgIdAndTxt("fusion_dydt_125:nlhs","One output required.");
    }

    int numel_xxxxx = mxGetNumberOfElements(prhs[input_xxxxx]));

    if( !mxIsDouble(prhs[input_xxxxx]) || numel_xxxxx != 3*(N-1)) {
        mexErrMsgIdAndTxt("fusion_dydt_125:notDouble",
            "Input vector xxxxx must have <%= num2str(3*(N-1)) %> == 3*(N-1) elements");
    }
	
    /* make sure the input "a" is scalar */
    if( !mxIsDouble(prhs[input_a]) || 
         mxIsComplex(prhs[input_a]) ||
         mxGetNumberOfElements(prhs[input_a])!=1 ) {
        mexErrMsgIdAndTxt("fusion_dydt_125:notScalar","Third arugment 'a' must be a scalar.");
    }

    /* make sure input "b" is scalar */
    if( !mxIsDouble(prhs[input_b]) || 
         mxIsComplex(prhs[input_b]) ||
         mxGetNumberOfElements(prhs[input_b])!=1 ) {
        mexErrMsgIdAndTxt("fusion_dydt_125:notScalar","Fourth argument 'b' must be a scalar.");
    }
    /* make sure the input "q_inf" is scalar */

    if( !mxIsDouble(prhs[input_q_inf]) || 
         mxIsComplex(prhs[input_q_inf]) ||
         mxGetNumberOfElements(prhs[input_q_inf])!=1 ) {
        mexErrMsgIdAndTxt("fusion_dydt_125:notScalar","Fifth argument 'q_inf' must be a scalar.");
    }
    
    /* get the values of the scalar inputs  */
    a     = mxGetScalar(prhs[input_a    ]);
    b     = mxGetScalar(prhs[input_b    ]);
    q_inf = mxGetScalar(prhs[input_q_inf]);

    /* create a pointer to the real data in the input matrix  */
    #if MX_HAS_INTERLEAVED_COMPLEX
    xxxxx = mxGetDoubles(prhs[input_xxxxx]);
    #else
    xxxxx = mxGetPr(prhs[input_xxxxx]);
    #endif

    /* get dimensions of the input matrix */
    //ncols = mxGetN(prhs[input_xxxxx]);

    /* create the sparse output matrix */ 
    int     nphases = 3*(N-1);

    plhs[0] = mxCreateSparse(nphases,nphases,nzmax,false);

    double*  jacobian_values      = mxGetPr(plhs[0]);
    mwIndex* jacobian_row_indices = mxGetIr(plhs[0]);
    mwIndex* jacobian_jc          = mxGetJc(plhs[0]);
    
    /* get a pointer to the real data in the output matrix */


  
    int     nnz = nzmax; // number of nonzero's
    mwIndex row_indices[]   = <%= row_indices %>;
    for (int i = 0; i < nnz; i++) {
      jacobian_row_indices[i] = row_indices[i];
    }
    // mexPrintf("jacobian row indices[1]%d\n",jacobian_row_indices[1]);

     
    int     jc_len  = nphases + 1;
    mwIndex jc[]   = <%= jc_str %>


    //for (int i=0; i< jc_len; i++) {
    //  mexPrintf("%jc[%d]: %d\n",i,jc[i]); 
    //}
    // mexPrintf("%d\n",jc[nphases]);
    for (int i = 0; i < jc_len; i++) {
      jacobian_jc[i] = jc[i];
    }
    //mexPrintf("%d\n",jacobian_jc[nphases]);

    

    fusion_jacobian(xxxxx,a,b,q_inf,jacobian_values);
}

void fusion_jacobian(double* xxxxx, double a, double b, double q_inf, double* jacobian_values) {
  <%= jacobian_values %>
}
