function multipliers = compute_multipliers(x, nMults_to_compute)
  global cds contopts;
  print_diag(3,'computing multipliers\n');
  [phases, period, parameters] = ...
    NewtonPicard.SingleShooting.extract_phases_period_and_parameters(x);
  
  integration_opt = odeset(...
    'AbsTol',      contopts.multipliers_abs_tol,    ...
    'RelTol',      contopts.multipliers_rel_tol     ...
  );
  if ~ isempty(cds.jacobian_ode)
    integration_opt = odeset(integration_opt, ...
          'Jacobian',     @(t,y) feval(cds.jacobian_ode,t,y,parameters{:}));
  end
  
  if ~ cds.using_cvode
    cds.cycle_orbit = cds.integrator(...
         @(t, y) cds.dydt_ode(t, y, parameters{:}), ...
         [0 period], ...
         phases(:,1), ...
         integration_opt);
  else
    [t,y] = cds.integrator( ...
      't_values',                linspace(0, period, cds.n_points_stored), ...
      'initial_point',           phases_0, ...
      'ode_parameters',          cell2mat(parameters), ...
      'abs_tol',                 contopts.integration_abs_tol, ...
      'rel_tol',                 contopts.integration_rel_tol);
    cds.t_values    = t;
    cds.cycle_orbit = y';
    cds.phases_0 = phases_0;
  end
 
  
  monodromy_map = @(x) NewtonPicard.SingleShooting.monodromy_map( ...
                        x, period, parameters, ...
                        contopts.multipliers_abs_tol, ...
                        contopts.multipliers_rel_tol);
  
  nMults_to_compute = min(nMults_to_compute, length(x) - 2);
                      
  [~, multiplier_matrix, no_convergence] = eigs(monodromy_map, cds.nphases, ...
                                                nMults_to_compute, ...
                                              'largestabs', ... 
                                              'Tolerance', 1e-12);
  multipliers = diag(multiplier_matrix);
  
  if no_convergence
    print_diag(2, 'multipliers did not converge\n');
    return
  end
  
  print_diag(1, multipliers2str(multipliers));
end