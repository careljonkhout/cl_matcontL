function Mx = monodromy_map(x, period, parameters, abs_tol, rel_tol)
  global cds contopts
  cds.mv_count = cds.mv_count + 1;
  if nargin == 3
    abs_tol = contopts.integration_abs_tol;
    rel_tol = contopts.integration_rel_tol;
  elseif nargin ~= 5
    error( ['The number of input arguments to ' ...
      'NewtonPicard.SingleShooting.monodromy_map is not correct.\n' ...
      'The number of input arguments should be either 3 or 5.\n' ...
      'The actual number of input arguments is %d.\n'], nargien);
  end
  integration_opt = odeset(...
      'AbsTol',       abs_tol, ...
      'RelTol',       rel_tol  ...
  );   
  if ~ contopts.monodromy_by_finite_differences

    integration_opt = odeset(integration_opt, ...
        'Jacobian',     @(t,y) feval(cds.jacobian_ode, ...
                                t, deval(cds.cycle_orbit,t), parameters{:}));
    dydt_mon = @(t, y) ...
      cds.jacobian_ode(t, deval(cds.cycle_orbit,t), parameters{:}) * y;
    [~,orbit] = cds.integrator(dydt_mon, [0 period], x, integration_opt);
    Mx = orbit(end,:)';
  else
    integration_opt = odeset(...
      'AbsTol',       1e-13, ...
      'RelTol',       1e-13  ...
    ); 
    % alternative method of applying the monodromy map to x:
    % by finite differences. Seems to be faster, but accuracy is limited
    h = 5e-5;
    x_cycle = deval(cds.cycle_orbit,0);
    f  = @(t, x) cds.dydt_ode(0,x,parameters{:});
    ff = @(t, x1_and_x2) [f(0, x1_and_x2(1:cds.nphases    ))
                          f(0, x1_and_x2(  cds.nphases+1:end))];
    [~, orbit] = ode15s(ff, ...
      [0 period], ...
      [x_cycle - h * x; x_cycle+h * x], ...
      integration_opt);
    
    phi_x1__and__phi_x2 = orbit(end,:)';
    phi_x1 = phi_x1__and__phi_x2(1:cds.nphases);
    phi_x2 = phi_x1__and__phi_x2(cds.nphases+1:end);
    
    Mx = (phi_x2 - phi_x1)/h/2; 
  end
end