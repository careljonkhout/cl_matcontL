// this file was generated by the system file generator of cl_matcontL

// this mex function computes the Jacobian matrix of system of ODEs called
//                       "brusselator_1d_N_50"

#include <math.h>
#include "mex.h"
#include "user_data.h"


#define N_INPUTS     N_PARAMETERS + 2

#define INPUT_T 0
#define INPUT_Y 1


void jacobian_dydt_mex(double* u, double* parameters, double* jacobian);

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {

  double parameters[N_PARAMETERS];  
  double *y;                      /* 1xN input matrix */
  double *outMatrix;              /* output matrix */



  for ( int i = 0; i < N_PARAMETERS; i++ ) {
    if ( !mxIsDouble(prhs[i + 2]) ) {
      mexErrMsgIdAndTxt("brusselator_1d_N_50_dydt:not_double",
                        "Error: one of the parameters is not a double");
    } else if ( mxIsComplex(prhs[i + 2]) ) {
      mexErrMsgIdAndTxt("brusselator_1d_N_50_dydt:not_complex",
                        "Error: one of the parameters not a real number");
    } else if ( mxGetNumberOfElements(prhs[i + 2]) != 1 ) {
      mexErrMsgIdAndTxt("brusselator_1d_N_50_dydt:notScalar",
                        "Error: one of the parameters is not scalar");
    } else {
      parameters[i] = mxGetScalar(prhs[i+2]);
    }
  }

  
  int neq = PDE_DIMENSION * ((int) parameters[0]);

  
  /* check for proper number of arguments */
  
  if(nrhs != N_INPUTS) {
    mexErrMsgIdAndTxt("brusselator_1d_N_50_dydt:nrhs","Five inputs required.");
  }

  if ( !mxIsDouble(prhs[INPUT_Y]) ) {
    mexErrMsgIdAndTxt("system_brusselator_1d_N_50:not_double",
                      "Error: Input vector y is not a double.");
  }

  if ( mxGetNumberOfElements(prhs[INPUT_Y]) != neq ) {
    mexErrMsgIdAndTxt("system_brusselator_1d_N_50:wrong_size",
                     "Input vector y must have 100 elements.");
  }
    
    
  /* create a pointer to the real data in the input matrix  */
  #if MX_HAS_INTERLEAVED_COMPLEX
  y = mxGetDoubles(prhs[INPUT_Y]);
  #else
  y = mxGetPr(prhs[INPUT_Y]);
  #endif

  /* get dimensions of the input matrix */

  /* create the output matrix */
  plhs[0] = mxCreateDoubleMatrix(neq, neq, mxREAL);

  /* get a pointer to the real data in the output matrix */
  #if MX_HAS_INTERLEAVED_COMPLEX
  outMatrix = mxGetDoubles(plhs[0]);
  #else
  outMatrix = mxGetPr(plhs[0]);
  #endif

  /* call the computational routine */
  jacobian_dydt_mex(y, parameters, outMatrix);
    
}

#define X_INDEX(i) (2*(i))
#define Y_INDEX(i) (2*(i)+1)

#define X(i) u[X_INDEX(i)]
#define Y(i) u[Y_INDEX(i)]


#define ELEMENT(mat,i,j) mat[i + j*neq]

#define JAC_XX(i,j) ELEMENT(jacobian, X_INDEX(i), X_INDEX(j))
#define JAC_XY(i,j) ELEMENT(jacobian, X_INDEX(i), Y_INDEX(j))
#define JAC_YX(i,j) ELEMENT(jacobian, Y_INDEX(i), X_INDEX(j))
#define JAC_YY(i,j) ELEMENT(jacobian, Y_INDEX(i), Y_INDEX(j))


#define L  parameters[1]
#define A  parameters[2]
#define B  parameters[3]
#define DX parameters[4]
#define DY parameters[5]

void jacobian_dydt_mex(double* u, double* parameters, double* jacobian) {
  
  int n_mesh_points = (int) parameters[0];
  int neq = PDE_DIMENSION * ((int) parameters[0]);
  
  double cx = DX * (n_mesh_points + 1) * (n_mesh_points + 1) / (L*L);
  double cy = DY * (n_mesh_points + 1) * (n_mesh_points + 1) / (L*L);
  
  for ( int i = 0; i < n_mesh_points; i++ ) {
    JAC_XX(i,i) = - 2 * cx - (B+1) + 2 * X(i) * Y(i);
    JAC_XY(i,i) =   X(i) * X(i);
    JAC_YX(i,i) =   B - 2 * X(i) * Y(i);
    JAC_YY(i,i) = - 2 * cy - X(i) * X(i);
  }
  
  for ( int i = 0; i < n_mesh_points - 1; i++ ) {
    JAC_XX(i    , i + 1) = cx;
    JAC_XX(i + 1, i    ) = cx;
    JAC_YY(i    , i + 1) = cy;
    JAC_YY(i + 1, i    ) = cy;
  }
}