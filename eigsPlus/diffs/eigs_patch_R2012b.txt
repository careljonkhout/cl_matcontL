--- /Users/tim/research/libs/matlab/eigsplus2/sources/matlab/R2012b/eigs.m	2011-07-21 16:40:32.000000000 +0200
+++ /Users/tim/research/libs/matlab/eigsplus2/sources/modified/eigsPlus_R2012b.m	2016-11-22 13:23:29.000000000 +0100
@@ -1,4 +1,26 @@
-function  varargout = eigs(varargin)
+function  varargout = eigsPlus_R2012b(varargin)
+% 
+% eigsPlus autogenerated code
+% 
+% eigsPlus modified version of eigs.m (R2012b) makes the following changes:
+% 
+% 1) NaNs are used instead of zeros as padding in case not all eigenvalues
+%    converge, so it is obvious to the user what has occured.  This is a
+%    straightforward change, mostly (but not solely) consisting of changing 
+%    the initialization of the relevant arrays from =zeros() to =NaN(). 
+%
+% 2) a warning is thrown instead of an error when none of the eigenvalues
+%    converge and an array of NaN eigenvalues is returned. 
+%
+% 3) The optional third output argument now returns the number of ARPACK
+%    iterations.  0 is returned if a full eig call is done.  Flag is no
+%    longer returned as the user may check for the presence of NaNs is the
+%    eigenvalue output to determine if not all k requested eigenvalues
+%    converged to tolerance.
+%
+% 4) opts.isreal may be set to false to force the complex solver if A is 
+%    real and opts.v0 is real or if A is real and opts.v0 is complex.  
+%
 %EIGS  Find a few eigenvalues and eigenvectors of a matrix
 %   D = EIGS(A) returns a vector of A's 6 largest magnitude eigenvalues.
 %   A must be square and should be large and sparse.
@@ -166,8 +188,11 @@
             aupdfun = 'dsaupd';
             eupdfun = 'dseupd';
         end
-      lworkl = intconvert(p*(p+8));
-        d = zeros(k,1,classAB);
+        lworkl = intconvert(p*(p+8));
+        % EIGSPLUS modification block START 
+        % change zeros to NaNs so unconverged values are obvious
+        d = NaN(k,1,classAB);
+        % EIGSPLUS modification block END
     else % real but not symmetric
         if strcmp(classAB,'single')
             aupdfun = 'snaupd';
@@ -176,10 +201,13 @@
             aupdfun = 'dnaupd';
             eupdfun = 'dneupd';
         end
-      lworkl = intconvert(3*p*(p+2));
+        lworkl = intconvert(3*p*(p+2));
         workev = zeros(3*p,1,classAB);
-        d = zeros(k+1,1,classAB);
-        di = zeros(k+1,1,classAB);
+        % EIGSPLUS modification block START
+        % change zeros to NaNs so unconverged values are obvious
+        d = NaN(k+1,1,classAB);
+        di = NaN(k+1,1,classAB);
+        % EIGSPLUS modification block END
     end
     v = zeros(n,p,classAB);
     workd = zeros(n,3,classAB);
@@ -198,7 +226,10 @@
    lworkl = intconvert(2*(3*p^2+5*p));
    workl = zeros(lworkl,1,classAB);
     workev = zeros(2*2*p,1,classAB);
-    zd = zeros(2*(k+1),1,classAB);
+    % EIGSPLUS modification block START    
+    % change zeros to NaNs so unconverged values are obvious
+    zd = NaN(2*(k+1),1,classAB);
+    % EIGSPLUS modification block END
     rwork = zeros(p,1,classAB);
 end
 ldv = intconvert(n);
@@ -330,7 +361,11 @@
         if rvec
             d(k+1) = [];
         else
-            zind = find(d == 0);
+            % EIGSPLUS modification block START
+            % change zeros to NaNs so unconverged values are obvious
+            %zind = find(d == 0);
+            zind = find(isnan(d));
+            % EIGSPLUS modification block END
             if isempty(zind)
                 d = d(k+1:-1:2);
             else
@@ -366,9 +401,13 @@
     else
         varargout{1} = v(:,1:k);
         varargout{2} = diag(d(1:k,1));
-        if (nargout >= 3)
-            varargout{3} = flag;
-        end
+        % EIGSPLUS modification block START
+        % third output argument will be the number of ARPACK iters so this 
+        % is no longer needed
+%         if (nargout >= 3)
+%             varargout{3} = flag;
+%         end
+        % EIGSPLUS modification block END
     end
 else
     if (nargout <= 1)
@@ -381,9 +420,13 @@
             complex(v(:,cplxd),-v(:,cplxd+1))];
         varargout{1} = v(:,1:k);
         varargout{2} = diag(d);
-        if (nargout >= 3)
-            varargout{3} = flag;
-        end
+        % EIGSPLUS modification block START
+        % third output argument will be the number of ARPACK iters so this 
+        % is no longer needed
+%         if (nargout >= 3)
+%             varargout{3} = flag;
+%         end
+        % EIGSPLUS modification block END
     end
 end
 
@@ -407,6 +450,13 @@
     end
 end
 
+% EIGSPLUS modification block START
+% third output argument will be the number of ARPACK iters
+if nargout >= 3
+    varargout{3} = double(ipntr(15));
+end
+% EIGSPLUS modification block END
+
 cputms(4) = cputime-t0; % end timing post-processing
 
 cputms(5) = sum(cputms(1:4)); % total time
@@ -652,7 +702,11 @@
                     error(message('MATLAB:eigs:InvalidOptsIssym'));
                 end
             end
-            if isfield(opts,'isreal') && ~Amatrix
+            % EIGSPLUS modification block START
+            % allow forcing complex solver, with (real A and real v0) or 
+            % (real A and complex v0)
+            if isfield(opts,'isreal') % && ~Amatrix
+            % EIGSPLUS modification block END
                 if (opts.isreal ~= false) && (opts.isreal ~= true)
                     error(message('MATLAB:eigs:InvalidOptsIsreal'));
                 end
@@ -1170,7 +1224,11 @@
             varargout{1} = V(:,ind(range));
             varargout{2} = D(ind(range),ind(range));
             if (nOutputs == 3)
-                % flag indicates "convergence"
+                % EIGSPLUS modification block START
+                % update to comments only
+                % third output argument is the number of ARPACK iters
+                % if full eig is called, this will be 0 
+                % EIGSPLUS modification block END
                 varargout{3} = 0;
             end
         end
@@ -1326,7 +1384,11 @@
                 case 1
                     error(message('MATLAB:eigs:ARPACKroutineError01', eupdfun));
                 case -14
-                    error(message('MATLAB:eigs:ARPACKroutineErrorMinus14', eupdfun, aupdfun));
+                    % EIGSPLUS modification block START
+                    % instead of an error when no Ritz values converge, 
+                    % allow a normal return, but with a warning 
+                    warning(message('MATLAB:eigs:ARPACKroutineErrorMinus14', eupdfun, aupdfun));
+                    % EIGSPLUS modification block END
                 otherwise
                     error(message('MATLAB:eigs:ARPACKroutineError', eupdfun, full(info)));
             end
