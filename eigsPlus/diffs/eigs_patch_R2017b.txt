--- /Users/tim/research/releases/eigsPlus/sources/matlab/R2017b/eigs.m	2018-03-20 15:14:16.000000000 +0100
+++ /Users/tim/research/releases/eigsPlus/sources/modified/eigsPlus_R2017b.m	2018-03-28 12:23:49.000000000 +0200
@@ -1,4 +1,20 @@
-function [V, D, flag] = eigs(varargin)
+function [V, D, flag] = eigsPlus_R2017b(varargin)
+% 
+% eigsPlus autogenerated code
+% 
+% eigsPlus modified version of eigs.m (R2017b) makes the following change:
+%
+% 1) The optional third output argument now returns the number of
+%    iterations of the new Krylov Schur algorithm, introduced in R2017b and
+%    which replaces ARPACK used in previous versions of MATLAB.  0 is
+%    returned if a full eig call is done.  Flag is no longer returned as
+%    the user may check for the presence of NaNs is the eigenvalue output
+%    to determine if not all k requested eigenvalues converged to
+%    tolerance.
+%
+% Note that opts.isreal, which used to be to select which variant of the
+% ARPACK routines is called, is no longer a relevant feature for eigsPlus.
+%
 % EIGS   Find a few eigenvalues and eigenvectors of a matrix
 %  D = EIGS(A) returns a vector of A's 6 largest magnitude eigenvalues.
 %  A must be square and should be large and sparse.
@@ -109,11 +125,16 @@
         V = fullEig(A, B, n, k, cholB, permB, scaleB, eigsSigma);
     else
         [V, D] = fullEig(A, B, n, k, cholB, permB, scaleB, eigsSigma);
-        if strcmp(innerOpts.fail,'keep')
-            flag = false(k,1);
-        else
-            flag = 0;
-        end
+        % EIGSPLUS modification block START
+        % flag is only used to return the number of iterations.
+        % In the dense case, this is zero.
+        % if strcmp(innerOpts.fail,'keep')
+        %    flag = false(k,1);
+        % else
+        %    flag = 0;
+        % end
+        flag = 0;
+        % EIGSPLUS modification block END
     end
     return
 end
@@ -123,8 +144,11 @@
     Amatrix, innerOpts);
 
 % Send variables to KS and run algorithm
-[V, d, isNotConverged, spdBout, VV] = KrylovSchur(applyOP, applyM, innerOpts, n, k,...
+% EIGSPLUS modification block START
+% added returning the number of KrylovSchur iterations
+[V, d, isNotConverged, spdBout, VV, iters] = KrylovSchur(applyOP, applyM, innerOpts, n, k,...
     shiftAndInvert, randStr, spdB);
+% EIGSPLUS modification block END
 
 % Do some post processing of the output for generalized problem
 [V, d, isNotConverged] = postProcessing(V, d, isNotConverged, eigsSigma, B, scaleB, ...
@@ -153,18 +177,22 @@
 end
 
 % Give correct output based on Failure Treatment option (replacenan is default)
+% EIGSPLUS modification block START
+% flag is only used to return the number of iterations.
 if strcmpi(innerOpts.fail,'keep')
-    flag = isNotConverged;
+    % flag = isNotConverged;
 elseif strcmpi(innerOpts.fail,'drop')
     d = d(~isNotConverged);
     if nargout > 1
         V = V(:,~isNotConverged);
     end
-    flag = double(any(isNotConverged));
+    % flag = double(any(isNotConverged));
 else
     d(isNotConverged) = NaN;
-    flag = double(any(isNotConverged));
+    % flag = double(any(isNotConverged));
 end
+flag = iters;
+% EIGSPLUS modification block END
 
 % If flag is not returned, give warning about convergence failure
 if nargout < 3 && any(isNotConverged)
@@ -1254,8 +1282,11 @@
 end
 end
 
-function [V, d, isNotConverged, spdB, VV] = KrylovSchur(applyOP, applyM, ...
+% EIGSPLUS modification block START
+% added returning the number of KrylovSchur iterations
+function [V, d, isNotConverged, spdB, VV, iters] = KrylovSchur(applyOP, applyM, ...
     innerOpts, n, k, shiftAndInvert, randStr, spdB)
+% EIGSPLUS modification block END
 
 if innerOpts.disp
     disp(['--- ' getString(message('MATLAB:eigs:StartKrylovSchur')) ' ---']);
@@ -1277,14 +1308,18 @@
 
 innerOpts.v0 = v;
 
+% EIGSPLUS modification block START
+% added returning the number of KrylovSchur iterations
 if innerOpts.ishermprob
-    [V, d, isNotConverged, stopAlgorithm] = KSherm(applyOP, applyM, n, k, ...
+    [V, d, isNotConverged, stopAlgorithm, iters] = KSherm(applyOP, applyM, n, k, ...
         innerOpts, randStr, shiftAndInvert);
     VV = V; % V already orthogonal
 else
-    [V, d, isNotConverged, stopAlgorithm, VV] = KSnonherm(applyOP, applyM, n, k, ...
+    [V, d, isNotConverged, stopAlgorithm, VV, iters] = KSnonherm(applyOP, applyM, n, k, ...
         innerOpts, randStr, shiftAndInvert);
 end
+iters_prev = iters;
+% EIGSPLUS modification block END
 
 if stopAlgorithm
     if spdB && shiftAndInvert
@@ -1301,8 +1336,12 @@
         innerOpts.v0 = v;
         applyOP = @(x) applyOP(applyM(x));
         applyM = @(x) x;
-        [V, d, isNotConverged, stopAlgorithm, VV] = KSnonherm(applyOP, applyM, n, k, ...
+        % EIGSPLUS modification block START
+        % added returning the number of KrylovSchur iterations
+        [V, d, isNotConverged, stopAlgorithm, VV, iters] = KSnonherm(applyOP, applyM, n, k, ...
             innerOpts, randStr, shiftAndInvert);
+        iters = iters + iters_prev;
+        % EIGSPLUS modification block END
     end
     
     if stopAlgorithm
@@ -1317,8 +1356,11 @@
 
 end
 
-function [U, d, isNotConverged, stopAlgorithm] = KSherm(applyOP, applyM, n, k, ...
+% EIGSPLUS modification block START
+% added returning the number of KrylovSchur iterations
+function [U, d, isNotConverged, stopAlgorithm, mm] = KSherm(applyOP, applyM, n, k, ...
     innerOpts, randStr, shiftAndInvert)
+% EIGSPLUS modification block END
 % Applies Krylov Schur algorithm for Hermitian matrices (reference 1)
 
 % Get previously set algorithm options
@@ -1462,8 +1504,11 @@
 
 end
 
-function [U, d, isNotConverged, stopAlgorithm, V] = KSnonherm(applyOP, applyM, n, k, ...
+% EIGSPLUS modification block START
+% added returning the number of KrylovSchur iterations
+function [U, d, isNotConverged, stopAlgorithm, V, mm] = KSnonherm(applyOP, applyM, n, k, ...
     innerOpts, randStr, shiftAndInvert)
+% EIGSPLUS modification block END
 % Applies Krylov Schur algorithm for non-Hermitian matrices (reference 1)
 
 % Get previously set algorithm options
